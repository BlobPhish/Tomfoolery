## Step 1: Identify Your Scope
Ensure you have a clear understanding of the scope of your penetration test. Know which devices, systems, and networks are in scope for testing, and obtain proper authorization if required.

![image](https://github.com/BlobPhish/Tomfoolery/assets/144268718/fecf7af6-58d4-4687-9154-61675791796e)

### Switch3 
10.20.0.1

Found (2) Open and (1) Closed

**Port: 53/tcp** 
Open
Service: domain
Version: Unbound


**Port: 113/tcp**
Closed
Service: ident
Version: nginx


**Port: 853/tcp** 
Open
Service: domain-s
Version: unknown

Nothing of great significance could be found here.

### Target PFSense
192.168.122.47

When the target network was scanned using:

```
nmap -Pn 192.168.122.47 
```

Port 53 and port 80 was shown open indicating:

port 53/tcp is open and the associated service is "domain." Port 53 is commonly used for DNS (Domain Name System) services.

port 80/tcp is open, and the associated service is "http." Port 80 is commonly used for HTTP (Hypertext Transfer Protocol) web services.

This hinted that there is a webpage associated with the ports that are open. 

I opened Firefox (or whatever web browser) and typed in the IP address. I was directed to the following page:

![image](https://github.com/BlobPhish/Tomfoolery/assets/144268718/ac4ce881-6d86-4788-b26f-7762bc32723f)

I used the following dirb tool to perform directory and file scanning on a web server located at the IP address 192.168.122.47. 

```
dirb hittp://192.168.122.47/ | tee dirb_output
```

**dirb:** This is the name of the command or executable that you are running. dirb is a popular web application directory and file brute-forcing tool used for discovering hidden directories and files on web servers.

**http://192.168.122.47/:** This part of the command specifies the target URL where dirb should perform its directory and file scanning. In this case, it's http://192.168.122.47/, which means dirb will scan the web server hosted at the IP address 192.168.122.47.

**|:** The pipe symbol (|) is used to pass the output of one command as input to another command. In this case, it redirects the output of the dirb command to the next command.

**tee:** tee is a command that reads from standard input and writes to standard output and files simultaneously. It is often used to capture command output and save it to a file while still displaying it on the terminal.

**dirb_output:** This is the filename where the output of the dirb command will be saved. In this case, it will create a file named dirb_output in the current directory to store the results of the dirb scan.

The following results are shown:

![image](https://github.com/BlobPhish/Tomfoolery/assets/144268718/1f0a4bad-1e97-4a71-858f-7928b4f44114)

The results of the scan was entered into the web browser:

![image](https://github.com/BlobPhish/Tomfoolery/assets/144268718/fac8d0d5-78ed-47b4-a365-c286d7c1abc0)

Observe the URL, This yielded nothing of value and the links direct you pictures of cats and minecraft.

However, the second result shows a view.php (Parent directory will take you back the cat main page)

![image](https://github.com/BlobPhish/Tomfoolery/assets/144268718/c8a72d45-297c-41c7-882d-7cf6a235bc39)

When you click on the link, it will take you to something a little more interesting:

![image](https://github.com/BlobPhish/Tomfoolery/assets/144268718/887129cb-0c4b-482c-b1c8-29736ec1903c)

From here we can try a Command Line Injection using:

```
;
```

When you can type a semicolon (;) into a login or input field on a web application, and it results in the execution of commands as if you were interacting with a Linux command line, it's often referred to as a "Command Injection" vulnerability or attack.

Command Injection occurs when an application doesn't properly validate or sanitize user input and allows malicious users to inject and execute arbitrary system commands. This can be a serious security flaw, as it enables attackers to run commands on the underlying server or system where the web application is hosted, potentially leading to unauthorized access, data leakage, or other security breaches.

Using the basic command for identifying the user in Linux, prefaced with the semi-colon:

```
;id
```

The following is shown:

![image](https://github.com/BlobPhish/Tomfoolery/assets/144268718/e79f5e5f-6482-415e-9795-1f30a5c11b42)

The **id** command in Unix-like operating systems is used to display information about the user's identity, including their user ID (UID), group ID (GID), and group memberships. In your case, the output of the id command is as follows:

**uid=33(www-data):** This indicates that the user's UID is 33, and their username is www-data. The UID (User ID) is a unique numeric identifier for a user.

**gid=33(www-data):** This shows that the user's primary group is www-data. The GID (Group ID) is a unique numeric identifier for a group.

**groups=33(www-data):** This indicates that the user is a member of the group www-data. In Unix-like systems, users can belong to multiple groups, but in this case, the user is only a member of the www-data group.














### App1
192.168.1.121

STATUS: Root Access

### FS1
192.168.1.124

80/tcp (http)


135/tcp (msrpc)


139/tcp (netbios-ssn)


445/tcp (microsoft-ds)


3389/tcp (ms-wbt-server)


49152/tcp (unknown)


49153/tcp (unknown)


49154/tcp (unknown)


49155/tcp (unknown)


49156/tcp (unknown)


49158/tcp (unknown)



### DHCP1
192.168.1.123


135/tcp (msrpc)


139/tcp (netbios-ssn)


445/tcp (microsoft-ds)


3389/tcp (ms-wbt-server)


### DC1
192.168.1.125

7/tcp

9/tcp

13/tcp

17/tcp

19/tcp

53/tcp

80/tcp

88/tcp

135/tcp

139/tcp

389/tcp

443/tcp

445/tcp

464/tcp

515/tcp

593/tcp

636/tcp

3268/tcp

3269/tcp

3389/tcp

49152/tcp

49153/tcp

49154/tcp

49155/tcp

49157/tcp

49158/tcp

49159/tcp

49165/tcp

### Dev1
192.168.1.117

9999/tcp (abyss)

### SOC1
192.168.1.108

135/tcp

139/tcp

445/tcp

5357/tcp

49152/tcp

49153/tcp

49154/tcp

49155/tcp

49156/tcp

49157/tcp

### SOC2
192.168.1.111

22/tcp

23/tcp

80/tcp

3389/tcp

### SOC3
192.168.1.122

135/tcp

139/tcp

445/tcp

3389/tcp

8009/tcp

8080/tcp

### SOC4
192.168.1.102

22/tcp

23/tcp

3389/tcp

5432/tcp

### SOC5
192.168.1.109

22/tcp

23/tcp

3389/tcp

10000/tcp

### SOC6
192.168.1.101

22/tcp

111/tcp

631/tcp

### SOC7
Doesn't show up on nmap scan

## Attack Boxes

### PFSense
192.168.2.72

### KALI1
192.168.2.72

### KALI2
192.168.2.73

### KALI3
192.168.2.76

### KALI4 
192.168.2.77


## Step 2: Network Mapping 
Use network scanning tools like Nmap to identify active hosts on the network and discover open ports and services. This information will help you understand the network's topology and potential entry points.
```
nmap -sn 192.168.1.0/24
```
